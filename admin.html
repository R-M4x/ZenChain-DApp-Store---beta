<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZenChain Store</title>
    <style>
        :root {
            --primary-green: #00FF88;
            --secondary-cyan: #00CCDD;
            --tertiary-lime: #88FF44;
            --accent-yellow: #CCFF66;
            --zen-gradient: linear-gradient(135deg, #d9ff66, #0cda7a, #00CCDD);
            --background-dark: #0D1F1A;
            --surface-green: #1A2E26;
            --surface-light: #243530;
            --surface-hover: #2F4138;
            --text-light: #E8FFF3;
            --text-secondary: #B8E6D1;
            --text-muted: #8FA89D;
            --border-green: rgba(0, 255, 136, 0.3);
            --border-cyan: rgba(0, 204, 221, 0.3);
            --glow-green: 0 0 20px rgba(0, 255, 136, 0.4);
            --error-red: #ff4757;
            --warning-orange: #ffa502;
            --success-green: #2ed573;
            --info-blue: #70a1ff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--background-dark);
            color: var(--text-light);
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 1rem;
        }

        /* Header */
        .header {
            background: var(--surface-light);
            border-bottom: 2px solid var(--border-green);
            padding: 1rem 0;
            position: sticky;
            top: 0;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .logo-section {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .logo {
            width: 50px;
            height: 50px;
            background: var(--zen-gradient);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        .header-title {
            font-size: 1.8rem;
            font-weight: 700;
            background: linear-gradient(90deg, #CCFF66, #00FF88, #00CCDD);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header-subtitle {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-top: -0.2rem;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .wallet-status {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            background: var(--surface-green);
            border: 1px solid var(--border-green);
            border-radius: 12px;
            font-size: 0.9rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--error-red);
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: var(--success-green);
        }

        .wallet-info {
            display: flex;
            flex-direction: column;
            gap: 0.1rem;
        }

        .wallet-address {
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            color: var(--primary-green);
            font-weight: 600;
        }

        .wallet-balance {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .connect-wallet-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            background: var(--zen-gradient);
            color: var(--background-dark);
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .connect-wallet-btn:hover {
            box-shadow: var(--glow-green);
            transform: translateY(-2px);
        }

        .quick-links {
            display: flex;
            gap: 0.5rem;
        }

        .quick-link {
            padding: 0.5rem 1rem;
            background: transparent;
            border: 1px solid var(--border-cyan);
            border-radius: 8px;
            color: var(--secondary-cyan);
            text-decoration: none;
            font-size: 0.85rem;
            transition: all 0.3s ease;
        }

        .quick-link:hover {
            background: rgba(0, 204, 221, 0.1);
            transform: translateY(-1px);
        }

        /* Stats Bar - FIXED to prevent overflow */
        .stats-bar {
            background: var(--surface-green);
            border-bottom: 1px solid var(--border-green);
            padding: 1rem 0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 1rem;
        }

        .stat-card {
            background: var(--surface-light);
            border: 1px solid var(--border-green);
            border-radius: 12px;
            padding: 1rem;
            text-align: center;
            transition: all 0.3s ease;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .stat-card:hover {
            transform: translateY(-2px);
            border-color: var(--primary-green);
        }

        .stat-number {
            font-size: 1.8rem;
            font-weight: 700;
            background: var(--zen-gradient);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.25rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .stat-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            font-weight: 500;
            line-height: 1.2;
        }

        /* Main Dashboard - FIXED LAYOUT (2 columns max) */
        .main-dashboard {
            padding: 2rem 0;
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            /* FIXED: Only 2 columns */
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .dashboard-card {
            background: var(--surface-green);
            border: 1px solid var(--border-green);
            border-radius: 16px;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .dashboard-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 40px rgba(0, 255, 136, 0.15);
        }

        .card-header {
            background: var(--surface-light);
            padding: 1.25rem;
            border-bottom: 2px solid var(--border-green);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .card-icon {
            width: 40px;
            height: 40px;
            background: var(--zen-gradient);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: var(--background-dark);
        }

        .card-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--text-light);
            flex: 1;
        }

        .card-body {
            padding: 1.5rem;
        }

        .button-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .dashboard-btn {
            padding: 0.75rem 1rem;
            background: var(--surface-light);
            border: 1px solid var(--border-green);
            border-radius: 10px;
            color: var(--text-light);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.85rem;
            text-align: center;
        }

        .dashboard-btn:hover {
            background: var(--surface-hover);
            border-color: var(--primary-green);
            transform: translateY(-2px);
        }

        .dashboard-btn.primary {
            background: var(--zen-gradient);
            color: var(--background-dark);
            border-color: transparent;
        }

        .dashboard-btn.danger {
            background: var(--error-red);
            border-color: var(--error-red);
            color: white;
        }

        .dashboard-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .output-panel {
            background: var(--surface-light);
            border: 1px solid var(--border-cyan);
            border-radius: 12px;
            padding: 1rem;
            max-height: 350px;
            /* INCREASED HEIGHT */
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .output-panel::-webkit-scrollbar {
            width: 6px;
        }

        .output-panel::-webkit-scrollbar-track {
            background: var(--surface-green);
            border-radius: 3px;
        }

        .output-panel::-webkit-scrollbar-thumb {
            background: var(--border-green);
            border-radius: 3px;
        }

        /* Status Messages */
        .status-message {
            padding: 1rem;
            border-radius: 10px;
            margin: 0.5rem 0;
            border-left: 4px solid;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .status-message.success {
            background: rgba(46, 213, 115, 0.1);
            border-left-color: var(--success-green);
            color: var(--success-green);
        }

        .status-message.error {
            background: rgba(255, 71, 87, 0.1);
            border-left-color: var(--error-red);
            color: var(--error-red);
        }

        .status-message.warning {
            background: rgba(255, 165, 2, 0.1);
            border-left-color: var(--warning-orange);
            color: var(--warning-orange);
        }

        .status-message.info {
            background: rgba(112, 161, 255, 0.1);
            border-left-color: var(--info-blue);
            color: var(--info-blue);
        }

        /* Purchase Items */
        .purchase-item {
            background: var(--surface-green);
            border: 1px solid var(--border-green);
            border-left: 4px solid var(--primary-green);
            border-radius: 8px;
            padding: 1rem;
            margin: 0.75rem 0;
            transition: all 0.3s ease;
        }

        .purchase-item:hover {
            border-left-color: var(--secondary-cyan);
            background: var(--surface-hover);
        }

        .purchase-item.new {
            border-left-color: var(--accent-yellow);
            animation: highlight 2s ease-out;
        }

        .purchase-header {
            font-weight: 700;
            color: var(--primary-green);
            margin-bottom: 0.5rem;
            font-size: 0.95rem;
        }

        .purchase-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 0.5rem;
            font-size: 0.8rem;
        }

        .detail-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .detail-icon {
            font-size: 0.9rem;
        }

        .tx-link {
            color: var(--secondary-cyan);
            text-decoration: none;
        }

        .tx-link:hover {
            text-decoration: underline;
        }

        /* Product Management */
        .product-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            gap: 1rem;
            max-height: 350px;
            overflow-y: auto;
        }

        .product-item {
            background: var(--surface-light);
            border: 1px solid var(--border-green);
            border-radius: 12px;
            padding: 1rem;
            transition: all 0.3s ease;
        }

        .product-item:hover {
            transform: translateY(-2px);
            border-color: var(--primary-green);
        }

        .product-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.75rem;
        }

        .product-emoji {
            font-size: 1.5rem;
        }

        .product-id {
            background: var(--zen-gradient);
            color: var(--background-dark);
            padding: 0.2rem 0.5rem;
            border-radius: 6px;
            font-size: 0.7rem;
            font-weight: 700;
        }

        .product-name {
            font-weight: 600;
            color: var(--text-light);
            margin-bottom: 0.3rem;
            font-size: 0.9rem;
            line-height: 1.3;
        }

        .product-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
        }

        .product-price {
            background: linear-gradient(90deg, #CCFF66, #00FF88);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 600;
        }

        .product-stock {
            font-weight: 500;
        }

        .stock-low {
            color: var(--warning-orange);
        }

        .stock-out {
            color: var(--error-red);
        }

        .product-actions {
            display: flex;
            gap: 0.5rem;
        }

        .product-btn {
            flex: 1;
            padding: 0.4rem 0.6rem;
            border: 1px solid var(--border-green);
            border-radius: 6px;
            background: transparent;
            color: var(--text-light);
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.3s ease;
        }

        .product-btn:hover {
            background: var(--surface-hover);
            border-color: var(--primary-green);
        }

        .product-btn.danger {
            border-color: var(--error-red);
            color: var(--error-red);
        }

        .product-btn.danger:hover {
            background: rgba(255, 71, 87, 0.1);
        }

        /* Form Styles */
        .form-group {
            margin-bottom: 1rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .form-input,
        .form-select {
            width: 100%;
            padding: 0.75rem;
            background: var(--surface-light);
            border: 1px solid var(--border-green);
            border-radius: 8px;
            color: var(--text-light);
            font-size: 0.9rem;
        }

        .form-input:focus,
        .form-select:focus {
            outline: none;
            border-color: var(--primary-green);
            box-shadow: 0 0 0 2px rgba(0, 255, 136, 0.2);
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: var(--surface-green);
            border: 2px solid var(--border-green);
            border-radius: 16px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1.5rem;
        }

        .modal-title {
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--primary-green);
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .modal-close:hover {
            color: var(--error-red);
            background: rgba(255, 71, 87, 0.1);
        }

        /* Animations */
        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        @keyframes highlight {
            0% {
                background: rgba(204, 255, 102, 0.2);
            }

            100% {
                background: transparent;
            }
        }

        /* Responsive Design - IMPROVED */
        @media (max-width: 1200px) {
            .stats-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 968px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
                /* Stack cards on smaller screens */
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                align-items: stretch;
            }

            .header-actions {
                justify-content: center;
            }

            .button-grid {
                grid-template-columns: 1fr;
            }

            .form-row {
                grid-template-columns: 1fr;
            }

            .product-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 600px) {
            .stats-grid {
                grid-template-columns: 1fr;
            }

            .dashboard-card {
                margin: 0 -0.5rem;
            }
        }
    </style>
</head>

<body>
    <!-- Header -->
    <header class="header">
        <div class="container">
            <div class="header-content">
                <div class="logo-section">
                    <img src="/media/icons/Zicon.png" alt="ZenChain Logo" class="logo-image">
                    <div>
                        <h1 class="header-title">ZenChain Admin Dashboard</h1>
                        <p class="header-subtitle">Store Management System</p>
                    </div>
                </div>

                <div class="header-actions">
                    <div class="wallet-status" id="wallet-status">
                        <div class="status-dot" id="status-dot"></div>
                        <div class="wallet-info">
                            <div class="wallet-address" id="wallet-display">Not Connected</div>
                            <div class="wallet-balance" id="balance-display">Connect wallet</div>
                        </div>
                    </div>

                    <button class="connect-wallet-btn" id="wallet-action">
                        <span>🔗</span>
                        <span id="wallet-action-text">Connect Wallet</span>
                    </button>

                    <div class="quick-links">
                        <a href="https://zentrace.io/address/0xBc3A065e47499227A1596CC64c7f417536654a82" target="_blank"
                            class="quick-link">
                            🔍 Explorer
                        </a>
                        <a href="https://faucet.zenchain.io" target="_blank" class="quick-link">
                            💧 Faucet
                        </a>
                        <a href="index.html" target="_blank" class="quick-link">
                            🛒 Store
                        </a>
                    </div>
                </div>
            </div>
        </div>
    </header>


    <!-- Main Dashboard -->
    <main class="main-dashboard">
        <div class="container">
            <div class="dashboard-grid">
                <!-- Purchase Monitoring -->
                <div class="dashboard-card">
                    <div class="card-header">
                        <div class="card-icon">📊</div>
                        <h2 class="card-title">Purchase Monitoring</h2>
                    </div>
                    <div class="card-body">
                        <div class="button-grid">
                            <button class="dashboard-btn primary" onclick="loadRecentPurchases()">Recent
                                Purchases</button>
                            <button class="dashboard-btn" onclick="loadPurchasesFromBlock()">From Block</button>
                            <button class="dashboard-btn" onclick="startLiveMonitoring()" id="live-btn">Start
                                Live</button>
                            <button class="dashboard-btn" onclick="checkContractStatus()">Contract Status</button>
                        </div>
                        <div class="output-panel" id="purchases-output">
                            Click "Recent Purchases" to load transaction history...
                        </div>
                    </div>
                </div>

                <!-- Financial Overview -->
                <div class="dashboard-card">
                    <div class="card-header">
                        <div class="card-icon">💰</div>
                        <h2 class="card-title">Financial Overview</h2>
                    </div>
                    <div class="card-body">
                        <div class="button-grid">
                            <button class="dashboard-btn primary" onclick="checkAdminBalance()">Admin Balance</button>
                            <button class="dashboard-btn" onclick="checkContractBalance()">Contract Balance</button>
                            <button class="dashboard-btn" onclick="withdrawFunds()">Withdraw Funds</button>
                            <button class="dashboard-btn" onclick="getNetworkInfo()">Network Info</button>
                        </div>
                        <div class="output-panel" id="financial-output">
                            Financial data will appear here...
                        </div>
                    </div>
                </div>

                <!-- Inventory Management -->
                <div class="dashboard-card">
                    <div class="card-header">
                        <div class="card-icon">📦</div>
                        <h2 class="card-title">Inventory Management</h2>
                    </div>
                    <div class="card-body">
                        <div class="button-grid">
                            <button class="dashboard-btn primary" onclick="viewAllProducts()">View Products</button>
                            <button class="dashboard-btn" onclick="showAddProductModal()">Add Product</button>
                            <button class="dashboard-btn" onclick="showStockManager()">Manage Stock</button>
                            <button class="dashboard-btn danger" onclick="showDeleteProductModal()">Delete
                                Product</button>
                        </div>
                        <div class="output-panel" id="inventory-output">
                            Click "View Products" to see inventory...
                        </div>
                    </div>
                </div>

                <!-- System Analytics -->
                <div class="dashboard-card">
                    <div class="card-header">
                        <div class="card-icon">📈</div>
                        <h2 class="card-title">Transaction Debug Tools</h2>
                    </div>
                    <div class="card-body">
                        <div class="button-grid">
                            <button class="dashboard-btn primary" onclick="debugLastTransaction()">Debug Last
                                TX</button>
                            <button class="dashboard-btn" onclick="checkGasSettings()">Check Gas</button>
                            <button class="dashboard-btn" onclick="validateContract()">Validate Contract</button>
                            <button class="dashboard-btn" onclick="exportErrorLogs()">Export Errors</button>
                        </div>
                        <div class="output-panel" id="analytics-output">
                            Transaction debugging tools will appear here...
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Add Product Modal -->
    <div class="modal" id="add-product-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Add New Product</h3>
                <button class="modal-close" onclick="closeModal('add-product-modal')">&times;</button>
            </div>
            <form id="add-product-form">
                <div class="form-group">
                    <label class="form-label">Product Name</label>
                    <input type="text" class="form-input" id="product-name" required>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Price (ZTC)</label>
                        <input type="number" class="form-input" id="product-price" step="0.01" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Stock Quantity</label>
                        <input type="number" class="form-input" id="product-stock" required>
                    </div>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Category</label>
                        <select class="form-select" id="product-category" required>
                            <option value="">Select Category</option>
                            <option value="digital">Digital</option>
                            <option value="nft">NFT</option>
                            <option value="gaming">Gaming</option>
                            <option value="apparel">Apparel</option>
                            <option value="accessories">Accessories</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Emoji/Icon</label>
                        <input type="text" class="form-input" id="product-emoji" placeholder="📦">
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Description</label>
                    <input type="text" class="form-input" id="product-description" required>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Delivery Type</label>
                        <select class="form-select" id="product-delivery">
                            <option value="Instant">Instant</option>
                            <option value="1-2 days">1-2 days</option>
                            <option value="3-5 days">3-5 days</option>
                            <option value="1-2 weeks">1-2 weeks</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Badge (Optional)</label>
                        <input type="text" class="form-input" id="product-badge" placeholder="Popular, Limited, etc.">
                    </div>
                </div>
                <div class="button-grid">
                    <button type="button" class="dashboard-btn"
                        onclick="closeModal('add-product-modal')">Cancel</button>
                    <button type="submit" class="dashboard-btn primary">Add Product</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Stock Manager Modal -->
    <div class="modal" id="stock-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Manage Stock</h3>
                <button class="modal-close" onclick="closeModal('stock-modal')">&times;</button>
            </div>
            <div id="stock-manager-content">
                Loading products...
            </div>
        </div>
    </div>

    <!-- Delete Product Modal -->
    <div class="modal" id="delete-product-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Delete Product</h3>
                <button class="modal-close" onclick="closeModal('delete-product-modal')">&times;</button>
            </div>
            <div id="delete-manager-content">
                Loading products...
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.8.0/dist/ethers.umd.min.js"></script>

    <script>
        console.log('🚀 ZenChain Admin Dashboard');

        // Contract Configuration
        const CONTRACT_ADDRESS = '0xBc3A065e47499227A1596CC64c7f417536654a82';
        const CONTRACT_ABI = [
            "function owner() external view returns (address)",
            "function getActiveProducts() external view returns (tuple(uint256 id, string name, uint256 price, uint256 stock, bool active, string category, string metadataURI)[])",
            "function getUserPurchases(address _user) external view returns (uint256[])",
            "function getPurchase(uint256 _purchaseId) external view returns (tuple(uint256 productId, address buyer, uint256 quantity, uint256 totalPrice, uint256 timestamp))",
            "function getProduct(uint256 _productId) external view returns (tuple(uint256 id, string name, uint256 price, uint256 stock, bool active, string category, string metadataURI))",
            "function addProduct(string memory _name, uint256 _price, uint256 _stock, string memory _category, string memory _metadataURI) external",
            "function updateStock(uint256 _productId, uint256 _newStock) external",
            "function deactivateProduct(uint256 _productId) external",
            "function withdrawZTC() external",
            "event ProductPurchased(uint256 indexed purchaseId, uint256 indexed productId, address indexed buyer, uint256 quantity, uint256 totalPrice)"
        ];

        // RPC Configuration
        const RPC_ENDPOINTS = [
            'https://zenchain-testnet.api.onfinality.io/public',
            'wss://zenchain-testnet.api.onfinality.io/public-ws'
        ];

        const ZENCHAIN_CONFIG = {
            chainId: 8408,
            chainIdHex: '0x20D8',
            chainName: 'ZenChain Testnet',
            nativeCurrency: { name: 'ZenChain Token', symbol: 'ZTC', decimals: 18 },
            rpcUrls: RPC_ENDPOINTS,
            blockExplorerUrls: ['https://zentrace.io']
        };

        // Global State
        let provider;
        let contract;
        let signer;
        let isMonitoring = false;
        let currentBlockNumber = 0;
        let walletConnected = false;
        let userAddress = null;
        let currentRpcIndex = 0;

        async function init() {
            if (typeof ethers === 'undefined') {
                showStatus('Ethers.js not loaded', 'error');
                return;
            }

            try {
                provider = await connectToValidRPC();     // retry-loop picks first healthy RPC
                if (!provider) throw new Error('All RPC endpoints failed');

                // read-only contract
                contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, provider);
                currentBlockNumber = await provider.getBlockNumber();
                updateStatus('Connected to ZenChain Testnet', 'success', 'purchases-output');

                // auto-connect wallet if MetaMask already authorised
                if (window.ethereum) {
                    const accts = await window.ethereum.request({ method: 'eth_accounts' });
                    if (accts.length > 0) { await connectWallet(); }
                }

                await updateAllStats();
                checkContractStatus();

            } catch (err) {
                console.error('Initialization failed:', err);
                updateStatus('Failed to connect: ' + err.message, 'error', 'purchases-output');
            }
        }


        // RPC CONNECTION with retry logic
        async function connectToValidRPC() {
            for (let i = 0; i < RPC_ENDPOINTS.length; i++) {
                const rpc = RPC_ENDPOINTS[i];
                try {
                    console.log('🔗 Trying RPC:', rpc);

                    const testProvider = new ethers.JsonRpcProvider(rpc, {
                        chainId: 8408,
                        name: 'zenchain-testnet'
                    });

                    // Test with timeout
                    const blockNumberPromise = testProvider.getBlockNumber();
                    const timeoutPromise = new Promise((_, reject) =>
                        setTimeout(() => reject(new Error('RPC timeout')), 10000)
                    );

                    await Promise.race([blockNumberPromise, timeoutPromise]);

                    currentRpcIndex = i;
                    console.log('✅ Connected to RPC:', rpc);
                    return testProvider;

                } catch (error) {
                    console.log(`❌ Failed RPC ${rpc}:`, error.message);
                    continue;
                }
            }
            return null;
        }

        async function connectWallet() {
            console.log('🔗 connectWallet called');

            if (!window.ethereum) {
                updateStatus('MetaMask not detected. Please install MetaMask.', 'error', 'dashboard-output');
                return;
            }

            try {
                updateStatus('Connecting wallet...', 'info', 'dashboard-output');

                // Request accounts
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                if (!accounts || accounts.length === 0) {
                    throw new Error('No accounts found');
                }

                // Create fresh provider and signer like diagnostic
                const browserProvider = new ethers.BrowserProvider(window.ethereum);
                const signerInstance = await browserProvider.getSigner();

                console.log('✅ Provider and signer created');

                // Update global variables
                provider = browserProvider;
                signer = signerInstance;
                userAddress = accounts[0];
                walletConnected = true;

                // Create contract with signer
                contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);

                // Switch network if needed
                const network = await provider.getNetwork();
                if (Number(network.chainId) !== 8408) {
                    try {
                        await window.ethereum.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: '0x20D8' }]
                        });
                    } catch (switchError) {
                        if (switchError.code === 4902) {
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: '0x20D8',
                                    chainName: 'ZenChain Testnet',
                                    nativeCurrency: { name: 'ZenChain Token', symbol: 'ZTC', decimals: 18 },
                                    rpcUrls: ['https://zenchain-testnet.api.onfinality.io/public'],
                                    blockExplorerUrls: ['https://zentrace.io']
                                }]
                            });
                        }
                    }

                    // Re-create provider after network switch
                    provider = new ethers.BrowserProvider(window.ethereum);
                    signer = await provider.getSigner();
                    contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
                }

                await updateWalletDisplay();
                await updateAllStats();

                updateStatus('✅ Wallet connected successfully!', 'success', 'dashboard-output');

            } catch (error) {
                console.error('❌ connectWallet failed:', error);

                // Reset state
                provider = null;
                signer = null;
                contract = null;
                walletConnected = false;
                userAddress = null;

                updateStatus(`Connection failed: ${error.message}`, 'error', 'dashboard-output');
            }
        }


        async function updateWalletDisplay() {
            console.log('🔄 updateWalletDisplay called');

            const statusDot = document.getElementById('status-dot');
            const walletDisplay = document.getElementById('wallet-display');
            const balanceDisplay = document.getElementById('balance-display');
            const walletAction = document.getElementById('wallet-action');
            const walletActionText = document.getElementById('wallet-action-text');

            if (walletConnected && userAddress) {
                console.log('👤 Wallet connected, updating display for:', userAddress);

                // Update connection status immediately
                if (statusDot) statusDot.classList.add('connected');
                if (walletDisplay) walletDisplay.textContent = `${userAddress.substring(0, 8)}...${userAddress.substring(34)}`;

                // Update action button
                if (walletActionText) walletActionText.textContent = 'Disconnect';
                if (walletAction) walletAction.onclick = disconnectWallet;

                // Enhanced balance loading with retries
                if (balanceDisplay) {
                    balanceDisplay.textContent = 'Loading...';

                    // Function to try getting balance with retries
                    async function tryGetBalance(attempt = 1, maxAttempts = 5) {
                        console.log(`💰 Balance attempt ${attempt}/${maxAttempts}`);

                        try {
                            // Wait a bit between attempts to avoid race conditions
                            if (attempt > 1) {
                                await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                            }

                            // Create fresh provider
                            const freshProvider = new ethers.BrowserProvider(window.ethereum);

                            // Wait for provider to be ready
                            await new Promise(resolve => setTimeout(resolve, 500));

                            // Get balance
                            const balance = await freshProvider.getBalance(userAddress);
                            const balanceZTC = parseFloat(ethers.formatEther(balance));

                            console.log(`✅ Balance attempt ${attempt} SUCCESS:`, balanceZTC.toFixed(4), 'ZTC');
                            balanceDisplay.textContent = `${balanceZTC.toFixed(4)} ZTC`;

                            // Update global provider on success
                            provider = freshProvider;

                            return true; // Success

                        } catch (error) {
                            console.log(`❌ Balance attempt ${attempt} failed:`, error.message);

                            if (attempt < maxAttempts) {
                                // Try again
                                return await tryGetBalance(attempt + 1, maxAttempts);
                            } else {
                                // All attempts failed
                                console.error('❌ All balance attempts failed after', maxAttempts, 'tries');
                                balanceDisplay.textContent = 'Balance unavailable';
                                return false;
                            }
                        }
                    }

                    // Start the retry process
                    tryGetBalance();
                }

            } else {
                console.log('🔌 Wallet not connected, showing disconnected state');

                // Disconnected state
                if (statusDot) statusDot.classList.remove('connected');
                if (walletDisplay) walletDisplay.textContent = 'Not Connected';
                if (balanceDisplay) balanceDisplay.textContent = 'Connect wallet';
                if (walletActionText) walletActionText.textContent = 'Connect Wallet';
                if (walletAction) walletAction.onclick = connectWallet;
            }
        }


        async function updateAllStats() {
            console.log('📊 updateAllStats called - Getting REAL blockchain data only');

            // Initialize all stats to loading state
            const statsElements = ['total-purchases', 'total-revenue', 'unique-customers', 'total-products', 'low-stock-count'];
            statsElements.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.textContent = '...';
            });

            try {
                // Create fresh provider and contract
                console.log('🔗 Creating fresh provider and contract...');
                const workingProvider = new ethers.BrowserProvider(window.ethereum);
                const workingContract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, workingProvider);

                // PART 1: Get Purchase Events (Real blockchain data)
                console.log('📡 Fetching purchase events from blockchain...');
                try {
                    const filter = workingContract.filters.ProductPurchased();
                    const events = await workingContract.queryFilter(filter, 0, 'latest');

                    console.log(`📦 Found ${events.length} real purchase events from blockchain`);

                    let totalRevenue = 0;
                    let uniqueCustomers = new Set();

                    events.forEach((event, index) => {
                        try {
                            console.log(`Event ${index}:`, {
                                buyer: event.args.buyer,
                                productId: event.args.productId.toString(),
                                quantity: event.args.quantity.toString(),
                                totalPrice: ethers.formatEther(event.args.totalPrice)
                            });

                            const revenue = parseFloat(ethers.formatEther(event.args.totalPrice));
                            totalRevenue += revenue;
                            uniqueCustomers.add(event.args.buyer.toLowerCase());
                        } catch (eventError) {
                            console.warn(`Error processing event ${index}:`, eventError);
                        }
                    });

                    // Update purchase stats with REAL data
                    document.getElementById('total-purchases').textContent = events.length;
                    document.getElementById('total-revenue').textContent = totalRevenue.toFixed(2);

                    console.log('📊 Purchase stats updated with REAL data:', {
                        purchases: events.length,
                        revenue: totalRevenue.toFixed(2)
                    });

                } catch (eventError) {
                    console.error('📦 Error fetching purchase events:', eventError);
                    document.getElementById('total-purchases').textContent = 'Error';
                    document.getElementById('total-revenue').textContent = 'Error';
                }

                // PART 2: Get Product Stats (Real blockchain data ONLY)
                console.log('📦 Fetching products from blockchain...');
                try {
                    const products = await workingContract.getActiveProducts();
                    console.log(`📦 Found ${products.length} real products from blockchain`);

                    // Log each product for verification
                    products.forEach((product, index) => {
                        console.log(`Product ${index}:`, {
                            id: product.id.toString(),
                            name: product.name,
                            price: ethers.formatEther(product.price),
                            stock: product.stock.toString(),
                            active: product.active,
                            category: product.category
                        });
                    });

                    let totalProducts = products.length;
                    let lowStockCount = 0;

                    // Count low stock items
                    products.forEach(product => {
                        const stock = Number(product.stock);
                        if (stock <= 5 && stock > 0) {
                            lowStockCount++;
                        }
                    });

                    // Update product stats with REAL blockchain data
                    document.getElementById('total-products').textContent = totalProducts;
                    document.getElementById('low-stock-count').textContent = lowStockCount;

                    console.log('📦 Product stats updated with REAL blockchain data:', {
                        totalProducts,
                        lowStockCount
                    });

                } catch (productError) {
                    console.error('📦 Error fetching products from blockchain:', productError);
                    document.getElementById('total-products').textContent = 'Error';
                    document.getElementById('low-stock-count').textContent = 'Error';
                }

                // Update global variables with working instances
                provider = workingProvider;
                contract = workingContract;

                console.log('✅ Stats update completed with REAL blockchain data only');

            } catch (error) {
                console.error('📊 General error updating stats:', error);

                // Set error state for failed stats
                statsElements.forEach(id => {
                    const element = document.getElementById(id);
                    if (element && element.textContent === '...') {
                        element.textContent = 'Error';
                    }
                });
            }
        }

        function fixStatsDirectly() {
            console.log("🔧 DIRECT FIX: Resetting stats immediately");

            // Reset all fake stats to 0 or correct values
            const fixes = {
                'total-purchases': '0',
                'total-revenue': '0.00',
                'total-products': '0',
                'low-stock-count': '0'
            };

            Object.keys(fixes).forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    console.log(`Fixing ${id}: ${element.textContent} -> ${fixes[id]}`);
                    element.textContent = fixes[id];
                }
            });

            // Hide unique customers immediately
            const uniqueCustomers = document.getElementById('unique-customers');
            if (uniqueCustomers) {
                const parentCard = uniqueCustomers.closest('.stat-card, .dashboard-stat, .stat-item');
                if (parentCard) {
                    parentCard.style.display = 'none';
                    console.log("✅ Unique customers hidden");
                }
            }

            console.log("✅ Direct stats fix applied");
        }

        // Call this immediately when page loads
        setTimeout(fixStatsDirectly, 1000);

        async function debugTest() {
            console.log("🔍 MANUAL DEBUG TEST STARTING...");

            // Test 1: Check current wallet state
            console.log("📱 Current wallet state:", {
                walletConnected,
                userAddress,
                hasProvider: !!provider,
                hasContract: !!contract
            });

            // Test 2: Try manual balance check
            if (userAddress) {
                try {
                    console.log("💰 Testing manual balance check...");
                    const testProvider = new ethers.BrowserProvider(window.ethereum);
                    const balance = await testProvider.getBalance(userAddress);
                    const balanceZTC = parseFloat(ethers.formatEther(balance));
                    console.log("✅ Manual balance test SUCCESS:", balanceZTC.toFixed(4), "ZTC");

                    // Update balance display directly
                    const balanceDisplay = document.getElementById('balance-display');
                    if (balanceDisplay) {
                        balanceDisplay.textContent = `${balanceZTC.toFixed(4)} ZTC`;
                        console.log("✅ Balance display updated manually");
                    }
                } catch (error) {
                    console.error("❌ Manual balance test FAILED:", error);
                }
            }

            // Test 3: Try manual stats check  
            try {
                console.log("📊 Testing manual stats check...");
                const testProvider = new ethers.BrowserProvider(window.ethereum);
                const testContract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, testProvider);

                // Get real products
                const products = await testContract.getActiveProducts();
                console.log("📦 Manual products test SUCCESS:", products.length, "products found");

                // Update stats directly
                document.getElementById('total-products').textContent = products.length;
                document.getElementById('low-stock-count').textContent = 0; // Reset fake number
                console.log("✅ Stats updated manually");

                // Get purchase events
                const filter = testContract.filters.ProductPurchased();
                const events = await testContract.queryFilter(filter, 0, 'latest');
                console.log("📦 Manual events test SUCCESS:", events.length, "events found");

                document.getElementById('total-purchases').textContent = events.length;
                document.getElementById('total-revenue').textContent = '0.00';

            } catch (error) {
                console.error("❌ Manual stats test FAILED:", error);
            }

            console.log("🔍 MANUAL DEBUG TEST COMPLETE");
        }



        // updateProductStats function
        async function updateProductStats() {
            try {
                if (!contract) {
                    document.getElementById('total-products').textContent = '-';
                    document.getElementById('low-stock-count').textContent = '-';
                    return;
                }

                const products = await contract.getActiveProducts();
                let totalProducts = products.length;
                let lowStockCount = 0;

                products.forEach(product => {
                    const stock = Number(product.stock);
                    if (stock <= 5 && stock > 0) {
                        lowStockCount++;
                    }
                });

                document.getElementById('total-products').textContent = totalProducts;
                document.getElementById('low-stock-count').textContent = lowStockCount;

            } catch (error) {
                console.error('📦 Error updating product stats:', error);
                document.getElementById('total-products').textContent = 'Error';
                document.getElementById('low-stock-count').textContent = 'Error';
            }
        }

        // Enhanced init function for admin
        async function init() {
            console.log('🚀 Admin: Initializing with enhanced features...');

            updateWalletDisplay();

            // Auto-connect if previously connected
            const wasConnected = localStorage.getItem('zenchain_wallet_connected');
            if (wasConnected && window.ethereum) {
                console.log('🔄 Auto-connecting previously connected wallet...');
                await connectWallet();
            }

            // Set up periodic stats refresh
            if (walletConnected && contract) {
                setInterval(async () => {
                    if (walletConnected && contract) {
                        await updateAllStats();
                    }
                }, 30000); // Every 30 seconds
            }
        }

        //troubleshooting info for failed transactions
        function showTransactionTroubleshooting() {
            const html = `
                <div class="status-message warning">
                    <strong>🔧 Transaction Troubleshooting</strong><br><br>
                    Based on ZenChain explorer showing failed transactions, here are likely causes:<br><br>

                    <strong>1. RPC Network Issues:</strong><br>
                    • ZenChain testnet has unstable RPC performance<br>
                    • Try different RPC endpoints<br>
                    • Wait and retry during less busy times<br><br>

                    <strong>2. Gas Limit Issues:</strong><br>
                    • Transactions may need higher gas limits<br>
                    • ZenChain testnet gas estimation can be inaccurate<br><br>

                    <strong>3. Contract State Issues:</strong><br>
                    • Product IDs might not exist in the contract<br>
                    • Stock levels might be different than expected<br>
                    • Contract functions may have changed<br><br>

                    💡 <strong>Recommended Actions:</strong><br>
                    • Use "Debug Last TX" to analyze failures<br>
                    • Check "Network Info" for current status<br>
                    • Try transactions during off-peak hours<br>
                    • Consider updating contract if needed
                </div>
            `;
            updateStatus(html, '', 'analytics-output');
        }

        function fixAdminWalletDisplay() {
            console.log('🔧 Admin: Fixing wallet display...');

            const connectBtn = document.getElementById('connect-wallet-btn');
            const walletInfo = document.getElementById('wallet-info');

            if (walletConnected && userAddress) {
                if (connectBtn) connectBtn.style.display = 'none';
                if (walletInfo) {
                    walletInfo.style.display = 'block';

                    if (provider) {
                        provider.getBalance(userAddress).then(balance => {
                            const balanceInZTC = ethers.formatEther(balance);
                            walletInfo.innerHTML = `
                        <div style="color: var(--primary-green); font-family: monospace;">${userAddress.substring(0, 8)}...${userAddress.substring(34)}</div>
                        <div style="color: var(--text-secondary); font-size: 0.9rem;">${parseFloat(balanceInZTC).toFixed(4)} ZTC</div>
                    `;
                            console.log('✅ Admin wallet display updated');
                        });
                    }
                }
            } else {
                if (connectBtn) connectBtn.style.display = 'block';
                if (walletInfo) walletInfo.style.display = 'none';
            }
        }

        // 2. Fix admin stats loading
        async function fixAdminStats() {
            console.log('📊 Admin: Loading real stats...');

            if (!contract) {
                console.log('❌ Contract not available');
                return;
            }

            try {
                // Get purchase events
                const filter = contract.filters.ProductPurchased();
                const events = await contract.queryFilter(filter, 0, 'latest');

                let totalRevenue = 0;
                const uniqueCustomers = new Set();

                events.forEach(event => {
                    totalRevenue += parseFloat(ethers.formatEther(event.args.totalPrice));
                    uniqueCustomers.add(event.args.buyer);
                });

                // Update stats elements if they exist
                const updateStat = (id, value) => {
                    const el = document.getElementById(id);
                    if (el) el.textContent = value;
                };

                updateStat('total-purchases', events.length.toString());
                updateStat('total-revenue', totalRevenue.toFixed(2));
                updateStat('unique-customers', uniqueCustomers.size.toString());

                // Get product stats
                const products = await contract.getActiveProducts();
                updateStat('total-products', products.length.toString());
                const lowStock = products.filter(p => Number(p.stock) <= 5 && Number(p.stock) > 0);
                updateStat('low-stock-count', lowStock.length.toString());

                console.log('✅ Admin stats updated');

            } catch (error) {
                console.error('❌ Error loading stats:', error);
            }
        }

        // 3. Fix edit and delete buttons
        function fixAdminButtons() {
            console.log('🔧 Admin: Fixing buttons...');

            // Style edit buttons
            document.querySelectorAll('.edit-btn').forEach(btn => {
                btn.style.cssText = `
            background: linear-gradient(135deg, #00FF88, #00CCDD);
            color: #0D1F1A;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            margin-right: 0.5rem;
            transition: all 0.2s ease;
        `;

                btn.onclick = function (e) {
                    e.preventDefault();
                    const productId = this.getAttribute('data-product-id') ||
                        this.closest('[data-product-id]')?.getAttribute('data-product-id');
                    if (productId) {
                        console.log('✏️ Edit product:', productId);
                        // Add your edit functionality here
                        alert(`Edit product ${productId} - functionality can be implemented`);
                    }
                };
            });

            // Style delete buttons  
            document.querySelectorAll('.delete-btn').forEach(btn => {
                btn.style.cssText = `
            background: linear-gradient(135deg, #ff4757, #ff3742);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        `;

                btn.onmouseenter = () => {
                    btn.style.transform = 'translateY(-2px)';
                    btn.style.boxShadow = '0 4px 12px rgba(255, 71, 87, 0.4)';
                };

                btn.onmouseleave = () => {
                    btn.style.transform = 'translateY(0)';
                    btn.style.boxShadow = 'none';
                };

                btn.onclick = function (e) {
                    e.preventDefault();
                    const productId = this.getAttribute('data-product-id') ||
                        this.closest('[data-product-id]')?.getAttribute('data-product-id');
                    if (productId) {
                        console.log('🗑️ Delete product:', productId);
                        if (confirm('Are you sure you want to delete this product?')) {
                            deleteProduct(parseInt(productId));
                        }
                    }
                };
            });

            console.log('✅ Admin buttons fixed');
        }

        function editProduct(productId) {
            console.log('✏️ Edit product clicked:', productId);

            if (!contract) {
                updateStatus('Please connect wallet and ensure contract is loaded', 'error', 'inventory-output');
                return;
            }

            // Create edit modal
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'flex';

            modal.innerHTML = `
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Edit Product #${productId}</h3>
                <button class="modal-close" onclick="this.closest('.modal').remove()">×</button>
            </div>
            <div class="modal-body">
                <form id="edit-product-form-${productId}">
                    <div class="form-group">
                        <label class="form-label">Product Name</label>
                        <input type="text" class="form-input" id="edit-name-${productId}" required>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">Price (ZTC)</label>
                            <input type="number" class="form-input" id="edit-price-${productId}" step="0.01" required>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Stock</label>
                            <input type="number" class="form-input" id="edit-stock-${productId}" required>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Metadata URI</label>
                        <input type="text" class="form-input" id="edit-metadata-${productId}">
                    </div>
                    <div class="form-row">
                        <button type="button" class="dashboard-btn" onclick="this.closest('.modal').remove()">Cancel</button>
                        <button type="submit" class="dashboard-btn primary">Update Product</button>
                    </div>
                </form>
            </div>
        </div>
    `;

            document.body.appendChild(modal);

            // Load current product data
            loadProductForEdit(productId);

            // Handle form submission
            document.getElementById(`edit-product-form-${productId}`).addEventListener('submit', async (e) => {
                e.preventDefault();
                await updateProductOnBlockchain(productId);
                modal.remove();
            });
        }

        // Load and update product functions
        async function loadProductForEdit(productId) {
            try {
                const product = await contract.getProduct(productId);
                document.getElementById(`edit-name-${productId}`).value = product.name;
                document.getElementById(`edit-price-${productId}`).value = ethers.formatEther(product.price);
                document.getElementById(`edit-stock-${productId}`).value = product.stock;
                document.getElementById(`edit-metadata-${productId}`).value = product.metadataURI;
            } catch (error) {
                updateStatus(`Error loading product: ${error.message}`, 'error', 'inventory-output');
            }
        }

        async function updateProductOnBlockchain(productId) {
            if (!walletConnected || !signer) {
                updateStatus('Please connect wallet', 'error', 'inventory-output');
                return;
            }

            try {
                const name = document.getElementById(`edit-name-${productId}`).value;
                const price = document.getElementById(`edit-price-${productId}`).value;
                const stock = document.getElementById(`edit-stock-${productId}`).value;
                const metadata = document.getElementById(`edit-metadata-${productId}`).value;

                const priceInWei = ethers.parseEther(price);

                updateStatus('Updating product on blockchain...', 'info', 'inventory-output');

                const tx = await contract.updateProduct(productId, name, priceInWei, stock, metadata, {
                    gasLimit: 300000,
                    gasPrice: ethers.parseUnits('100', 'gwei')
                });

                const receipt = await tx.wait();

                if (receipt.status === 1) {
                    updateStatus('Product updated successfully!', 'success', 'inventory-output');
                    setTimeout(() => viewAllProducts(), 2000);
                }

            } catch (error) {
                updateStatus(`Update failed: ${error.message}`, 'error', 'inventory-output');
            }
        }

        // Add blurred background for wallet connection
        function addAdminWalletBackdrop() {
            let backdrop = document.getElementById('admin-wallet-backdrop');
            if (!backdrop) {
                backdrop = document.createElement('div');
                backdrop.id = 'admin-wallet-backdrop';
                backdrop.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(13, 31, 26, 0.85);
            backdrop-filter: blur(8px);
            z-index: 998;
            display: none;
            opacity: 0;
            transition: all 0.3s ease;
        `;
                document.body.appendChild(backdrop);
            }

            // Show/hide functions
            window.showAdminBackdrop = () => {
                backdrop.style.display = 'block';
                setTimeout(() => backdrop.style.opacity = '1', 10);
            };

            window.hideAdminBackdrop = () => {
                backdrop.style.opacity = '0';
                setTimeout(() => backdrop.style.display = 'none', 300);
            };
        }

        // Enhanced connectWallet for admin
        const originalConnectWallet = connectWallet;
        connectWallet = async function () {
            showAdminBackdrop();

            try {
                await originalConnectWallet();

                // Apply fixes after connection
                setTimeout(() => {
                    fixAdminWalletDisplay();
                    fixAdminStats();
                    fixAdminButtons();
                    hideAdminBackdrop();
                }, 2000);

            } catch (error) {
                hideAdminBackdrop();
                throw error;
            }
        };

        // Initialize admin fixes
        document.addEventListener('DOMContentLoaded', function () {
            console.log('🔧 Admin minimal fixes loading...');

            addAdminWalletBackdrop();

            // Apply fixes periodically to catch dynamically loaded content
            setInterval(() => {
                if (walletConnected) {
                    fixAdminWalletDisplay();
                    fixAdminButtons();
                }
            }, 5000);

            console.log('✅ Admin minimal fixes loaded');
        });


        // DEBUG FUNCTIONS for transaction failures
        async function debugLastTransaction() {
            if (!walletConnected) {
                updateStatus('⚠️ Connect wallet to debug transactions', 'warning', 'analytics-output');
                return;
            }

            try {
                updateStatus('🔍 Analyzing last transaction...', 'info', 'analytics-output');

                // Get recent transactions for the connected wallet
                const latestBlock = await provider.getBlockNumber();
                const startBlock = Math.max(latestBlock - 100, 0);

                // simplified debug systrm
                const html = `
                    <div class="status-message info">
                        <strong>🔍 Transaction Debug Analysis</strong><br><br>

                        <strong>Current Network Status:</strong><br>
                        • RPC Endpoint: ${RPC_ENDPOINTS[currentRpcIndex]}<br>
                        • Latest Block: ${latestBlock}<br>
                        • Scanning Range: ${startBlock} - ${latestBlock}<br><br>

                        <strong>Common ZenChain Issues:</strong><br>
                        • Gas estimation failures<br>
                        • RPC timeout issues<br>
                        • Contract state synchronization<br>
                        • Network congestion during peak times<br><br>

                        <strong>Recommended Solutions:</strong><br>
                        • Increase gas limit to 500,000+<br>
                        • Add retry logic with delays<br>
                        • Use static gas price (50 Gwei)<br>
                        • Wait 30+ seconds between transactions
                    </div>
                `;
                updateStatus(html, '', 'analytics-output');

            } catch (error) {
                updateStatus('❌ Debug analysis failed: ' + error.message, 'error', 'analytics-output');
            }
        }

        async function checkGasSettings() {
            try {
                updateStatus('⛽ Checking gas settings...', 'info', 'analytics-output');

                const gasPrice = await provider.getFeeData();
                const block = await provider.getBlock('latest');

                const html = `
                    <div class="status-message info">
                        <strong>⛽ Gas Analysis</strong><br><br>

                        <strong>Current Network Gas:</strong><br>
                        • Gas Price: ${gasPrice.gasPrice ? ethers.formatUnits(gasPrice.gasPrice, 'gwei') : 'N/A'} Gwei<br>
                        • Max Fee: ${gasPrice.maxFeePerGas ? ethers.formatUnits(gasPrice.maxFeePerGas, 'gwei') : 'N/A'} Gwei<br>
                        • Block Gas Limit: ${block.gasLimit.toString()}<br>
                        • Block Gas Used: ${block.gasUsed.toString()}<br><br>

                        <strong>Recommended Settings for ZenChain:</strong><br>
                        • Gas Limit: 500,000 - 1,000,000<br>
                        • Gas Price: 50-100 Gwei<br>
                        • Timeout: 120 seconds<br><br>

                        <strong>Common Issues:</strong><br>
                        • ZenChain gas estimation is unreliable<br>
                        • Use manual gas settings<br>
                        • Increase limits for complex transactions
                    </div>
                `;
                updateStatus(html, '', 'analytics-output');

            } catch (error) {
                updateStatus('❌ Gas check failed: ' + error.message, 'error', 'analytics-output');
            }
        }

        async function validateContract() {
            try {
                updateStatus('🔍 Validating contract...', 'info', 'analytics-output');

                // Check if contract exists and has code
                const code = await provider.getCode(CONTRACT_ADDRESS);
                const balance = await provider.getBalance(CONTRACT_ADDRESS);

                let validationResults = [];

                if (code === '0x') {
                    validationResults.push('❌ No contract code at this address');
                } else {
                    validationResults.push(`✅ Contract exists (${(code.length / 2 - 1).toLocaleString()} bytes)`);
                }

                // Try to call a simple read function
                try {
                    const owner = await contract.owner();
                    validationResults.push(`✅ Owner function works: ${owner.substring(0, 10)}...`);
                } catch (error) {
                    validationResults.push(`❌ Owner function failed: ${error.message}`);
                }

                // Try to get active products
                try {
                    const products = await contract.getActiveProducts();
                    validationResults.push(`✅ getActiveProducts works: ${products.length} products`);
                } catch (error) {
                    validationResults.push(`❌ getActiveProducts failed: ${error.message}`);
                }

                const html = `
                    <div class="status-message ${code === '0x' ? 'error' : 'success'}">
                        <strong>🔍 Contract Validation Results</strong><br><br>

                        <strong>Contract Status:</strong><br>
                        ${validationResults.join('<br>')}<br><br>

                        <strong>Contract Details:</strong><br>
                        • Address: ${CONTRACT_ADDRESS}<br>
                        • Balance: ${ethers.formatEther(balance)} ZTC<br>
                        • Network: ZenChain Testnet<br><br>

                        <strong>Issues Found:</strong><br>
                        ${validationResults.filter(r => r.includes('❌')).length === 0 ?
                        '✅ No issues detected' :
                        'Contract functions may not be working properly'}
                    </div>
                `;
                updateStatus(html, '', 'analytics-output');

            } catch (error) {
                updateStatus('❌ Contract validation failed: ' + error.message, 'error', 'analytics-output');
            }
        }

        function exportErrorLogs() {
            try {
                const errorLog = {
                    timestamp: new Date().toISOString(),
                    network: 'ZenChain Testnet',
                    contractAddress: CONTRACT_ADDRESS,
                    rpcEndpoints: RPC_ENDPOINTS,
                    currentRpc: RPC_ENDPOINTS[currentRpcIndex],
                    walletConnected: walletConnected,
                    userAddress: userAddress,
                    issues: [
                        'Transaction failures on ZenChain testnet',
                        'RPC network performance issues',
                        'Gas estimation problems',
                        'Contract interaction failures'
                    ],
                    recommendations: [
                        'Use higher gas limits (500k+)',
                        'Implement retry logic',
                        'Try different RPC endpoints',
                        'Wait during off-peak hours'
                    ]
                };

                const blob = new Blob([JSON.stringify(errorLog, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `zenchain-error-log-${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                updateStatus('📁 Error log exported successfully!', 'success', 'analytics-output');

            } catch (error) {
                updateStatus('❌ Export failed: ' + error.message, 'error', 'analytics-output');
            }
        }

        async function connectWallet() {
            console.log('🔗 connectWallet called');

            if (!window.ethereum) {
                updateStatus('MetaMask not detected. Please install MetaMask.', 'error', 'dashboard-output');
                return;
            }

            try {
                updateStatus('Connecting wallet...', 'info', 'dashboard-output');

                // Request accounts
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                if (!accounts || accounts.length === 0) {
                    throw new Error('No accounts found');
                }

                console.log('✅ Accounts received:', accounts[0]);

                // Wait a bit for MetaMask to be ready
                await new Promise(resolve => setTimeout(resolve, 1000));

                // Create provider and signer with retry logic
                let attempts = 3;
                let providerReady = false;

                while (attempts > 0 && !providerReady) {
                    try {
                        console.log(`🔗 Provider creation attempt ${4 - attempts}/3`);

                        const browserProvider = new ethers.BrowserProvider(window.ethereum);

                        // Test provider by getting network
                        const network = await browserProvider.getNetwork();
                        console.log('✅ Provider ready, network:', network.chainId);

                        const signerInstance = await browserProvider.getSigner();
                        console.log('✅ Signer created');

                        // Update global variables
                        provider = browserProvider;
                        signer = signerInstance;
                        userAddress = accounts[0];
                        walletConnected = true;

                        // Create contract
                        contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);

                        providerReady = true;

                    } catch (error) {
                        console.log(`❌ Provider attempt ${4 - attempts} failed:`, error.message);
                        attempts--;
                        if (attempts > 0) {
                            console.log('⏳ Waiting before retry...');
                            await new Promise(resolve => setTimeout(resolve, 2000));
                        }
                    }
                }

                if (!providerReady) {
                    throw new Error('Failed to initialize provider after 3 attempts');
                }

                // Check network and switch if needed
                const network = await provider.getNetwork();
                if (Number(network.chainId) !== 8408) {
                    console.log('🔄 Switching to ZenChain...');
                    try {
                        await window.ethereum.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: '0x20D8' }]
                        });

                        // Wait for network switch
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        // Re-create provider after network switch
                        provider = new ethers.BrowserProvider(window.ethereum);
                        signer = await provider.getSigner();
                        contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);

                    } catch (switchError) {
                        if (switchError.code === 4902) {
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: '0x20D8',
                                    chainName: 'ZenChain Testnet',
                                    nativeCurrency: { name: 'ZenChain Token', symbol: 'ZTC', decimals: 18 },
                                    rpcUrls: ['https://zenchain-testnet.api.onfinality.io/public'],
                                    blockExplorerUrls: ['https://zentrace.io']
                                }]
                            });

                            // Re-create provider after adding network
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            provider = new ethers.BrowserProvider(window.ethereum);
                            signer = await provider.getSigner();
                            contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
                        }
                    }
                }

                // Wait before updating display to ensure everything is ready
                await new Promise(resolve => setTimeout(resolve, 1000));

                // Update display
                await updateWalletDisplay();

                // Update stats
                setTimeout(() => updateAllStats(), 2000);

                updateStatus('✅ Wallet connected successfully!', 'success', 'dashboard-output');
                console.log('✅ Wallet connection complete');

            } catch (error) {
                console.error('❌ connectWallet failed:', error);

                // Reset state
                provider = null;
                signer = null;
                contract = null;
                walletConnected = false;
                userAddress = null;

                await updateWalletDisplay();
                updateStatus(`Connection failed: ${error.message}`, 'error', 'dashboard-output');
            }
        }

        async function disconnectWallet() {
            walletConnected = false;
            signer = null;
            userAddress = null;
            contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, provider);
            updateWalletDisplay();
            showStatus('Wallet disconnected', 'info');
        }


        async function updateWalletDisplay() {
            console.log('🔄 Updating wallet display...', { walletConnected, userAddress });

            const statusDot = document.getElementById('status-dot');
            const walletDisplay = document.getElementById('wallet-display');
            const balanceDisplay = document.getElementById('balance-display');
            const walletAction = document.getElementById('wallet-action');
            const walletActionText = document.getElementById('wallet-action-text');

            if (walletConnected && userAddress) {
                // Connected state
                if (statusDot) statusDot.classList.add('connected');
                if (walletDisplay) walletDisplay.textContent = `${userAddress.substring(0, 8)}...${userAddress.substring(34)}`;

                try {
                    const balance = await provider.getBalance(userAddress);
                    if (balanceDisplay) balanceDisplay.textContent = `${parseFloat(ethers.formatEther(balance)).toFixed(4)} ZTC`;
                    console.log('💰 Balance updated:', ethers.formatEther(balance), 'ZTC');
                } catch (error) {
                    if (balanceDisplay) balanceDisplay.textContent = 'Balance error';
                    console.error('Balance update error:', error);
                }

                if (walletActionText) walletActionText.textContent = 'Disconnect';
                if (walletAction) walletAction.onclick = disconnectWallet;
            } else {
                // Disconnected state
                if (statusDot) statusDot.classList.remove('connected');
                if (walletDisplay) walletDisplay.textContent = 'Not Connected';
                if (balanceDisplay) balanceDisplay.textContent = 'Connect wallet';
                if (walletActionText) walletActionText.textContent = 'Connect Wallet';
                if (walletAction) walletAction.onclick = connectWallet;
            }
        }

        // HOTFIX: Add auto-refresh for admin balance
        let adminBalanceRefresh;

        function startAdminBalanceRefresh() {
            if (adminBalanceRefresh) clearInterval(adminBalanceRefresh);

            if (walletConnected && provider) {
                console.log('🔄 Starting admin balance auto-refresh...');
                adminBalanceRefresh = setInterval(async () => {
                    await updateWalletDisplay();
                }, 10000); // Every 10 seconds
            }
        }

        function stopAdminBalanceRefresh() {
            if (adminBalanceRefresh) {
                clearInterval(adminBalanceRefresh);
                adminBalanceRefresh = null;
            }
        }


        async function verifyOwnership() {
            if (!walletConnected || !signer) {
                showStatus('⚠️ Connect wallet to verify ownership', 'warning', 'inventory-output');
                return false;
            }

            try {
                const owner = await contract.owner();
                const currentAddress = await signer.getAddress();
                const isOwner = owner.toLowerCase() === currentAddress.toLowerCase();

                if (isOwner) {
                    showStatus('👑 Verified: You are the contract owner!', 'success', 'inventory-output');
                    return true;
                } else {
                    showStatus('⚠️ Warning: You are not the contract owner', 'warning', 'inventory-output');
                    return false;
                }
            } catch (error) {
                showStatus('❌ Failed to verify ownership: ' + error.message, 'error', 'inventory-output');
                return false;
            }
        }

        // Purchase Monitoring Functions
        async function loadRecentPurchases() {
            try {
                updateStatus('🔄 Loading recent purchases...', 'info', 'purchases-output');

                const latestBlock = await provider.getBlockNumber();
                const fromBlock = Math.max(latestBlock - 1000, 0);

                const filter = contract.filters.ProductPurchased();
                const events = await contract.queryFilter(filter, fromBlock, 'latest');

                displayPurchases(events, `Recent Purchases (Blocks ${fromBlock} - ${latestBlock})`);
                await updateAllStats();

            } catch (error) {
                console.error('❌ Error loading purchases:', error);
                updateStatus('❌ Error loading purchases: ' + error.message, 'error', 'purchases-output');

                // Show additional troubleshooting for purchase loading failures
                setTimeout(() => {
                    const troubleshootingHtml = `
                        <div class="status-message warning">
                            <strong>🔧 Purchase Loading Failed</strong><br><br>
                            This is likely due to ZenChain RPC issues. Try:<br>
                            • Wait a few minutes and retry<br>
                            • Use "From Block" with recent block number<br>
                            • Check ZenTrace explorer manually<br>
                            • Switch to a different RPC endpoint
                        </div>
                    `;
                    document.getElementById('purchases-output').innerHTML += troubleshootingHtml;
                }, 2000);
            }
        }

        async function loadPurchasesFromBlock() {
            try {
                const blockNumber = prompt('Enter starting block number (recent blocks work better):', Math.max(currentBlockNumber - 100, 0));
                if (!blockNumber) return;

                updateStatus(`🔄 Loading purchases from block ${blockNumber}...`, 'info', 'purchases-output');

                const filter = contract.filters.ProductPurchased();
                const events = await contract.queryFilter(filter, parseInt(blockNumber), 'latest');

                displayPurchases(events, `Purchases from Block ${blockNumber}`);

            } catch (error) {
                console.error('❌ Error loading purchases:', error);
                updateStatus('❌ Error: ' + error.message, 'error', 'purchases-output');
            }
        }

        function displayPurchases(events, title) {
            const output = document.getElementById('purchases-output');

            if (events.length === 0) {
                output.innerHTML = `
                    <div class="status-message warning">
                        <strong>${title}</strong><br>
                        No purchases found in this range.<br><br>
                        💡 This could mean:<br>
                        • No purchases have been made yet<br>
                        • Transactions are failing (check ZenTrace)<br>
                        • RPC sync issues with ZenChain<br>
                        • Contract events not being emitted properly<br><br>

                        🔗 <a href="https://zentrace.io/address/${CONTRACT_ADDRESS}?tab=txs" target="_blank" class="tx-link">
                        Check ZenTrace for Failed Transactions</a>
                    </div>
                `;
                return;
            }

            let html = `<div class="status-message success"><strong>${title}</strong><br>Found ${events.length} successful purchases</div>`;

            events.reverse().forEach((event, index) => {
                const args = event.args;
                const isNew = index < 3;

                html += `
                    <div class="purchase-item ${isNew ? 'new' : ''}">
                        <div class="purchase-header">
                            Purchase #${args.purchaseId}
                        </div>
                        <div class="purchase-details">
                            <div class="detail-item">
                                <span class="detail-icon">📦</span>
                                Product: ${args.productId}
                            </div>
                            <div class="detail-item">
                                <span class="detail-icon">👤</span>
                                ${args.buyer.substring(0, 10)}...
                            </div>
                            <div class="detail-item">
                                <span class="detail-icon">📊</span>
                                Qty: ${args.quantity}
                            </div>
                            <div class="detail-item">
                                <span class="detail-icon">💰</span>
                                ${ethers.formatEther(args.totalPrice)} ZTC
                            </div>
                            <div class="detail-item">
                                <span class="detail-icon">🔗</span>
                                <a href="https://zentrace.io/tx/${event.transactionHash}" target="_blank" class="tx-link">
                                    ${event.transactionHash.substring(0, 10)}...
                                </a>
                            </div>
                            <div class="detail-item">
                                <span class="detail-icon">📍</span>
                                Block: ${event.blockNumber}
                            </div>
                        </div>
                    </div>
                `;
            });

            output.innerHTML = html;
        }

        async function startLiveMonitoring() {
            const btn = document.getElementById('live-btn');

            if (isMonitoring) {
                contract.removeAllListeners("ProductPurchased");
                isMonitoring = false;
                btn.textContent = 'Start Live';
                btn.classList.remove('primary');
                updateStatus('⚫ Live monitoring stopped', 'info', 'purchases-output');
            } else {
                isMonitoring = true;
                btn.textContent = 'Stop Live';
                btn.classList.add('primary');
                updateStatus('🔴 Live monitoring started - Note: ZenChain RPC may have delays...', 'success', 'purchases-output');

                contract.on("ProductPurchased", (purchaseId, productId, buyer, quantity, totalPrice, event) => {
                    console.log('🆕 New purchase detected!', event);

                    const output = document.getElementById('purchases-output');
                    const newPurchase = `
                        <div class="purchase-item new">
                            <div class="purchase-header">
                                🆕 LIVE: Purchase #${purchaseId}
                            </div>
                            <div class="purchase-details">
                                <div class="detail-item">
                                    <span class="detail-icon">📦</span>
                                    Product: ${productId}
                                </div>
                                <div class="detail-item">
                                    <span class="detail-icon">👤</span>
                                    ${buyer.substring(0, 10)}...
                                </div>
                                <div class="detail-item">
                                    <span class="detail-icon">📊</span>
                                    Qty: ${quantity}
                                </div>
                                <div class="detail-item">
                                    <span class="detail-icon">💰</span>
                                    ${ethers.formatEther(totalPrice)} ZTC
                                </div>
                                <div class="detail-item">
                                    <span class="detail-icon">🕐</span>
                                    ${new Date().toLocaleString()}
                                </div>
                                <div class="detail-item">
                                    <span class="detail-icon">🔗</span>
                                    <a href="https://zentrace.io/tx/${event.log.transactionHash}" target="_blank" class="tx-link">
                                        ${event.log.transactionHash.substring(0, 10)}...
                                    </a>
                                </div>
                            </div>
                        </div>
                    `;

                    output.insertAdjacentHTML('afterbegin', newPurchase);
                    updateAllStats();
                    showStatus(`🆕 New purchase: ${quantity}x Product #${productId}!`, 'success');
                });
            }
        }

        async function checkContractStatus() {
            try {
                const code = await provider.getCode(CONTRACT_ADDRESS);
                if (code === '0x') {
                    updateStatus('❌ Contract not found at this address!', 'error', 'purchases-output');
                    return;
                }

                const balance = await provider.getBalance(CONTRACT_ADDRESS);
                const block = await provider.getBlockNumber();

                const html = `
                    <div class="status-message success">
                        <strong>✅ Contract Status: ACTIVE</strong><br><br>
                        📍 Address: ${CONTRACT_ADDRESS}<br>
                        💰 Contract Balance: ${ethers.formatEther(balance)} ZTC<br>
                        📊 Current Block: ${block}<br>
                        🔗 Network: ZenChain Testnet (${ZENCHAIN_CONFIG.chainId})<br>
                        📏 Contract Size: ${(code.length / 2 - 1).toLocaleString()} bytes<br>
                        🌐 RPC: ${RPC_ENDPOINTS[currentRpcIndex]}<br><br>

                        ⚠️ <strong>Known Issues:</strong><br>
                        • ZenChain RPC can be unstable<br>
                        • Transaction failures are common<br>
                        • Use higher gas limits for transactions<br><br>

                        🔗 <a href="https://zentrace.io/address/${CONTRACT_ADDRESS}" target="_blank" class="tx-link">
                        View on ZenTrace Explorer</a>
                    </div>
                `;

                document.getElementById('purchases-output').innerHTML = html;

            } catch (error) {
                updateStatus('❌ Error checking contract: ' + error.message, 'error', 'purchases-output');
            }
        }

        // Financial Functions
        async function checkAdminBalance() {
            console.log('💰 checkAdminBalance called, walletConnected:', walletConnected);

            if (!walletConnected || !userAddress) {
                updateStatus('Please connect wallet to check balance', 'warning', 'financial-output');
                return;
            }

            try {
                // Use fresh provider like diagnostic
                const workingProvider = new ethers.BrowserProvider(window.ethereum);
                console.log('💰 Getting admin balance with fresh provider...');

                const adminBalance = await workingProvider.getBalance(userAddress);
                const contractBalance = await workingProvider.getBalance(CONTRACT_ADDRESS);

                const adminZTC = parseFloat(ethers.formatEther(adminBalance));
                const contractZTC = parseFloat(ethers.formatEther(contractBalance));

                console.log('💰 Balances loaded:', { admin: adminZTC, contract: contractZTC });

                const html = `
            <div class="status-message success">
                <strong>💰 Financial Overview</strong><br><br>
                <strong>Your Balance:</strong> ${adminZTC.toFixed(4)} ZTC<br>
                <strong>Contract Balance:</strong> ${contractZTC.toFixed(4)} ZTC<br>
                <strong>Available to Withdraw:</strong> ${contractZTC.toFixed(4)} ZTC<br><br>
                ${adminZTC < 0.1 ? '⚠️ Low balance - get ZTC from faucet<br>' : ''}
                ${contractZTC > 0 ? '✅ Funds available for withdrawal' : '❌ No funds to withdraw yet'}<br><br>
                <a href="https://faucet.zenchain.io" target="_blank" class="tx-link">Get ZTC from Faucet</a>
            </div>
        `;

                document.getElementById('financial-output').innerHTML = html;

                // Update global provider
                provider = workingProvider;

            } catch (error) {
                console.error('❌ checkAdminBalance failed:', error);
                updateStatus(`Error checking balance: ${error.message}`, 'error', 'financial-output');
            }
        }


        async function checkContractBalance() {
            console.log('📊 checkContractBalance called');

            try {
                // Use fresh provider like diagnostic
                const workingProvider = new ethers.BrowserProvider(window.ethereum);
                console.log('💰 Getting contract balance with fresh provider...');

                const balance = await workingProvider.getBalance(CONTRACT_ADDRESS);
                const balanceZTC = parseFloat(ethers.formatEther(balance));

                console.log('💰 Contract balance:', balanceZTC, 'ZTC');

                const html = `
            <div class="status-message info">
                <strong>📊 Contract Balance</strong><br><br>
                <strong>Current Balance:</strong> ${balanceZTC.toFixed(4)} ZTC<br>
                <strong>Balance in Wei:</strong> ${balance.toString()}<br><br>
                ${balanceZTC > 0 ?
                        '✅ You can withdraw these funds if you are the owner' :
                        '❌ No funds in contract yet - normal if no purchases succeeded'
                    }<br><br>
                <a href="https://zentrace.io/address/${CONTRACT_ADDRESS}" target="_blank" class="tx-link">View on ZenTrace</a>
            </div>
        `;

                document.getElementById('financial-output').innerHTML = html;

                // Update global provider
                provider = workingProvider;

            } catch (error) {
                console.error('❌ checkContractBalance failed:', error);
                updateStatus(`Error checking contract balance: ${error.message}`, 'error', 'financial-output');
            }
        }



        async function initializeAdminDashboard() {
            console.log('🚀 Initializing admin dashboard...');

            await updateWalletDisplay();

            // Auto-refresh every 10 seconds
            setInterval(async () => {
                if (contract) {
                    await updateAllStats();
                    await updateWalletDisplay();
                }
            }, 10000);

            if (contract) {
                await updateAllStats();
            }
        }

        async function withdrawFunds() {
            if (!walletConnected) {
                updateStatus('⚠️ Please connect wallet to withdraw funds', 'warning', 'financial-output');
                return;
            }

            try {
                updateStatus('🔄 Processing withdrawal...', 'info', 'financial-output');

                //higher gas limit for ZenChain
                const tx = await contract.withdrawZTC({
                    gasLimit: 500000,
                    gasPrice: ethers.parseUnits('100', 'gwei') // Fixed gas price
                });

                updateStatus('⏳ Waiting for confirmation (may take 2+ minutes on ZenChain)...', 'info', 'financial-output');

                const receipt = await tx.wait();

                const html = `
                    <div class="status-message success">
                        <strong>✅ Withdrawal Successful!</strong><br><br>
                        🔗 Transaction: <a href="https://zentrace.io/tx/${receipt.hash}" target="_blank" class="tx-link">${receipt.hash.substring(0, 20)}...</a><br>
                        ⛽ Gas Used: ${receipt.gasUsed}<br>
                        📊 Block: ${receipt.blockNumber}<br>
                        💰 Funds transferred to your wallet<br><br>
                        🎉 Check your wallet balance!
                    </div>
                `;

                document.getElementById('financial-output').innerHTML = html;

                // wallet display
                setTimeout(updateWalletDisplay, 3000);

            } catch (error) {
                console.error('❌ Withdrawal failed:', error);
                let errorMsg = error.message;

                if (error.message.includes('insufficient funds')) {
                    errorMsg = 'Insufficient funds for gas fees';
                } else if (error.message.includes('user rejected')) {
                    errorMsg = 'Transaction cancelled by user';
                } else if (error.message.includes('timeout')) {
                    errorMsg = 'Transaction timed out - may still be pending';
                }

                updateStatus('❌ Withdrawal failed: ' + errorMsg, 'error', 'financial-output');
            }
        }

        async function getNetworkInfo() {
            try {
                const network = await provider.getNetwork();
                const block = await provider.getBlockNumber();
                const gasPrice = await provider.getFeeData();

                const html = `
                    <div class="status-message info">
                        <strong>🌐 Network Information</strong><br><br>
                        🔗 Chain ID: ${network.chainId}<br>
                        🏷️ Chain Name: ${network.name}<br>
                        📊 Latest Block: ${block}<br>
                        ⛽ Gas Price: ${gasPrice.gasPrice ? ethers.formatUnits(gasPrice.gasPrice, 'gwei') : 'N/A'} Gwei<br>
                        🚀 RPC Status: ${RPC_ENDPOINTS[currentRpcIndex]} ✅<br><br>

                        <strong>ZenChain Testnet Info:</strong><br>
                        • Network can be unstable<br>
                        • High gas limits recommended<br>
                        • Transactions may take 2+ minutes<br>
                        • Use 50-100 Gwei gas price
                    </div>
                `;

                document.getElementById('financial-output').innerHTML = html;
            } catch (error) {
                updateStatus('❌ Error getting network info: ' + error.message, 'error', 'financial-output');
            }
        }

        // Inventory Management Functions
        async function viewAllProducts() {
            console.log('🔍 ADMIN DIAGNOSTIC: Loading products...');

            try {
                updateStatus('🔍 DIAGNOSTIC: Connecting to smart contract...', 'info', 'inventory-output');

                if (!contract) {
                    console.log('❌ ADMIN DIAGNOSTIC: Contract not available');
                    updateStatus('❌ DIAGNOSTIC: Smart contract not connected. Please connect wallet first.', 'error', 'inventory-output');
                    return;
                }

                console.log('🔍 ADMIN DIAGNOSTIC: Contract address:', contract.target || contract.address);
                console.log('🔍 ADMIN DIAGNOSTIC: Calling getActiveProducts()...');

                // Load products from smart contract
                const contractProducts = await contract.getActiveProducts();

                console.log('🔍 ADMIN DIAGNOSTIC: Raw contract response:', contractProducts);
                console.log(`🔍 ADMIN DIAGNOSTIC: Found ${contractProducts.length} products`);

                if (contractProducts.length === 0) {
                    updateStatus('🔍 DIAGNOSTIC: No products found in smart contract. Add some products first!', 'warning', 'inventory-output');
                    return;
                }

                // Process and display products
                const processedProducts = contractProducts.map((product, index) => {
                    console.log(`🔍 ADMIN DIAGNOSTIC: Processing product ${index + 1}:`, {
                        id: product.id.toString(),
                        name: product.name,
                        price: ethers.formatEther(product.price),
                        stock: product.stock.toString(),
                        active: product.active,
                        category: product.category,
                        metadataURI: product.metadataURI
                    });

                    return {
                        id: Number(product.id),
                        name: product.name,
                        price: ethers.formatEther(product.price),
                        stock: Number(product.stock),
                        active: product.active,
                        category: product.category,
                        metadataURI: product.metadataURI,
                        metadata: parseMetadata(product.metadataURI)
                    };
                });

                displayProducts(processedProducts, `🔍 DIAGNOSTIC: Smart Contract Products (${contractProducts.length})`);

            } catch (error) {
                console.error('❌ ADMIN DIAGNOSTIC: Error loading products:', error);
                console.error('❌ ADMIN DIAGNOSTIC: Error details:', error.message);
                updateStatus(`❌ DIAGNOSTIC: Error loading products: ${error.message}`, 'error', 'inventory-output');
            }
        }

        // Helper function to parse metadata
        function parseMetadata(metadataURI) {
            if (!metadataURI) return {};

            try {
                if (metadataURI.startsWith('{') && metadataURI.endsWith('}')) {
                    return JSON.parse(metadataURI);
                }
                return { description: metadataURI };
            } catch (error) {
                return { description: metadataURI };
            }
        }

        function getStoreProducts() {
            try {
                const products = localStorage.getItem('zenchain_products');
                return products ? JSON.parse(products) : null;
            } catch (error) {
                console.log('Could not access store products');
                return null;
            }
        }

        function displayProducts(products, title) {
            console.log('🔍 ADMIN DIAGNOSTIC: Displaying', products.length, 'products');

            const output = document.getElementById('inventory-output');
            if (!output) return;

            let html = `
        <div class="section-title">
            <h3>${title}</h3>
            <div class="products-count">${products.length} items</div>
        </div>
        <div class="products-grid">
    `;

            products.forEach(product => {
                const metadata = product.metadata || {};
                const image = metadata.image || '📦';

                console.log('🔍 ADMIN DIAGNOSTIC: Displaying product:', {
                    id: product.id,
                    name: product.name,
                    active: product.active
                });

                html += `
            <div class="product-item ${!product.active ? 'inactive' : ''}" data-product-id="${product.id}">
                <div class="product-header">
                    <div class="product-image">${image}</div>
                    <div class="product-status ${product.active ? 'active' : 'inactive'}">
                        ${product.active ? 'Active' : 'Inactive'}
                    </div>
                </div>
                <div class="product-details">
                    <h4 class="product-name">${product.name}</h4>
                    <div class="product-info-grid">
                        <div class="info-item">
                            <label>ID:</label>
                            <span>${product.id}</span>
                        </div>
                        <div class="info-item">
                            <label>Price:</label>
                            <span>${product.price} ZTC</span>
                        </div>
                        <div class="info-item">
                            <label>Stock:</label>
                            <span>${product.stock}</span>
                        </div>
                        <div class="info-item">
                            <label>Category:</label>
                            <span>${product.category}</span>
                        </div>
                        <div class="info-item full-width">
                            <label>Description:</label>
                            <span>${metadata.description || 'No description'}</span>
                        </div>
                    </div>
                </div>
                <div class="product-actions">
                    <button class="action-btn edit-btn" onclick="editProduct(${product.id})">
                        Edit
                    </button>
                    <button class="action-btn delete-btn" 
                            onclick="console.log('🔍 DIAGNOSTIC: Delete clicked for product ${product.id}'); deleteProduct(${product.id})" 
                            ${!product.active ? 'disabled' : ''}>
                        ${product.active ? 'Delete' : 'Deleted'}
                    </button>
                </div>
            </div>
        `;
            });

            html += `</div>`;

            output.innerHTML = html;
            console.log('🔍 ADMIN DIAGNOSTIC: Products displayed successfully');
        }

        function displayDefaultProducts() {
            const defaultProducts = [
                { id: 1, name: 'ZenChain Gift Card - 10 ZTC', price: '10', image: '💳', stock: 100 },
                { id: 2, name: 'ZenChain Gift Card - 25 ZTC', price: '25', image: '💎', stock: 50 },
                { id: 5, name: 'ZenChain Genesis NFT', price: '50', image: '🖼️', stock: 10 },
                { id: 7, name: 'Gaming Mouse RGB Pro', price: '45', image: '🖱️', stock: 15 },
                { id: 11, name: 'Hardware Wallet', price: '120', image: '🔐', stock: 8 }
            ];

            displayProducts(defaultProducts, 'Default Products (Demo)');
        }

        function adjustStock(productId, adjustment) {
            try {
                const products = getStoreProducts();
                if (!products) {
                    showStatus('❌ Cannot access store products', 'error');
                    return;
                }

                const product = products.find(p => p.id === productId);
                if (!product) {
                    showStatus('❌ Product not found', 'error');
                    return;
                }

                const newStock = Math.max(0, product.stock + adjustment);
                product.stock = newStock;

                localStorage.setItem('zenchain_products', JSON.stringify(products));
                viewAllProducts(); // Refresh display

                const action = adjustment > 0 ? 'increased' : 'decreased';
                showStatus(`✅ Stock ${action}: ${product.name} now has ${newStock} units`, 'success');

            } catch (error) {
                console.error('❌ Error adjusting stock:', error);
                showStatus('❌ Error adjusting stock: ' + error.message, 'error');
            }
        }

        function confirmDeleteProduct(productId) {
            const product = getStoreProducts()?.find(p => p.id === productId);
            if (!product) {
                showStatus('❌ Product not found', 'error');
                return;
            }

            if (confirm(`Are you sure you want to delete "${product.name}"?\n\nThis cannot be undone and may cause issues if customers try to purchase this product.`)) {
                deleteProduct(productId);
            }
        }

        async function deleteProduct(productId) {
            console.log('🔍 ADMIN DIAGNOSTIC: Attempting to delete product:', productId);

            if (!contract) {
                console.log('❌ ADMIN DIAGNOSTIC: Contract not available for deletion');
                updateStatus('❌ DIAGNOSTIC: Smart contract not connected', 'error', 'inventory-output');
                return;
            }

            try {
                // First, check if product exists
                console.log('🔍 ADMIN DIAGNOSTIC: Checking if product exists...');

                const product = await contract.getProduct(productId);
                console.log('🔍 ADMIN DIAGNOSTIC: Product found:', {
                    id: product.id.toString(),
                    name: product.name,
                    active: product.active
                });

                if (!product.active) {
                    console.log('⚠️ ADMIN DIAGNOSTIC: Product already inactive');
                    updateStatus('⚠️ DIAGNOSTIC: Product is already deactivated', 'warning', 'inventory-output');
                    return;
                }

                updateStatus('🔍 DIAGNOSTIC: Deactivating product on blockchain...', 'info', 'inventory-output');

                // Call smart contract deactivateProduct
                console.log('🔍 ADMIN DIAGNOSTIC: Calling contract.deactivateProduct...');
                const tx = await contract.deactivateProduct(productId, {
                    gasLimit: 300000,
                    gasPrice: ethers.parseUnits('100', 'gwei')
                });

                console.log('🔍 ADMIN DIAGNOSTIC: Transaction submitted:', tx.hash);
                updateStatus('🔍 DIAGNOSTIC: Waiting for transaction confirmation...', 'info', 'inventory-output');

                const receipt = await tx.wait();

                if (receipt.status === 1) {
                    console.log('✅ ADMIN DIAGNOSTIC: Product deactivated successfully');
                    updateStatus(`✅ DIAGNOSTIC: Product "${product.name}" deactivated successfully!`, 'success', 'inventory-output');

                    // Refresh product list
                    setTimeout(() => {
                        viewAllProducts();
                    }, 2000);
                } else {
                    console.log('❌ ADMIN DIAGNOSTIC: Transaction failed');
                    updateStatus('❌ DIAGNOSTIC: Transaction failed', 'error', 'inventory-output');
                }

            } catch (error) {
                console.error('❌ ADMIN DIAGNOSTIC: Error deleting product:', error);
                console.error('❌ ADMIN DIAGNOSTIC: Error details:', error.message);

                let errorMsg = error.message;
                if (error.message.includes('Product not found')) {
                    errorMsg = 'Product not found in smart contract';
                } else if (error.message.includes('user rejected')) {
                    errorMsg = 'Transaction cancelled by user';
                } else if (error.message.includes('insufficient funds')) {
                    errorMsg = 'Insufficient funds for gas fees';
                }

                updateStatus(`❌ DIAGNOSTIC: Error deleting product: ${errorMsg}`, 'error', 'inventory-output');
            }
        }

        function showAddProductModal() {
            document.getElementById('add-product-modal').classList.add('show');
        }

        function showStockManager() {
            const modal = document.getElementById('stock-modal');
            const content = document.getElementById('stock-manager-content');

            const products = getStoreProducts();
            if (!products) {
                content.innerHTML = '<div class="status-message error">Cannot access store products</div>';
                modal.classList.add('show');
                return;
            }

            let html = '<div class="product-grid">';
            products.forEach(product => {
                const stockClass = product.stock === 0 ? 'stock-out' : product.stock <= 5 ? 'stock-low' : '';

                html += `
                    <div class="product-item">
                        <div class="product-header">
                            <span class="product-emoji">${product.image || '📦'}</span>
                            <span class="product-id">${product.name}</span>
                        </div>
                        <div class="product-details">
                            <span class="product-stock ${stockClass}">Stock: ${product.stock}</span>
                        </div>
                        <div class="product-actions">
                            <button class="product-btn" onclick="adjustStock(${product.id}, 5); showStockManager();">+5</button>
                            <button class="product-btn" onclick="adjustStock(${product.id}, 10); showStockManager();">+10</button>
                            <button class="product-btn" onclick="adjustStock(${product.id}, -5); showStockManager();">-5</button>
                            <button class="product-btn" onclick="setCustomStock(${product.id})">Set</button>
                        </div>
                    </div>
                `;
            });
            html += '</div>';

            content.innerHTML = html;
            modal.classList.add('show');
        }

        function setCustomStock(productId) {
            const newStock = prompt('Enter new stock amount:');
            if (newStock === null || newStock === '') return;

            const stockNumber = parseInt(newStock);
            if (isNaN(stockNumber) || stockNumber < 0) {
                showStatus('❌ Invalid stock amount', 'error');
                return;
            }

            try {
                const products = getStoreProducts();
                const product = products.find(p => p.id === productId);
                if (product) {
                    product.stock = stockNumber;
                    localStorage.setItem('zenchain_products', JSON.stringify(products));
                    showStockManager(); // Refresh modal
                    showStatus(`✅ Set stock for ${product.name} to ${stockNumber}`, 'success');
                }
            } catch (error) {
                showStatus('❌ Error setting stock: ' + error.message, 'error');
            }
        }

        function showDeleteProductModal() {
            const modal = document.getElementById('delete-product-modal');
            const content = document.getElementById('delete-manager-content');

            const products = getStoreProducts();
            if (!products) {
                content.innerHTML = '<div class="status-message error">Cannot access store products</div>';
                modal.classList.add('show');
                return;
            }

            let html = '<div style="margin-bottom: 1rem;"><strong>⚠️ Select products to delete (PERMANENT):</strong></div>';
            html += '<div class="product-grid">';

            products.forEach(product => {
                html += `
                    <div class="product-item">
                        <div class="product-header">
                            <span class="product-emoji">${product.image || '📦'}</span>
                            <span class="product-id">ID: ${product.id}</span>
                        </div>
                        <div class="product-name" style="font-size: 0.8rem;">${product.name}</div>
                        <div class="product-details">
                            <span>${product.price} ZTC</span>
                            <span>Stock: ${product.stock}</span>
                        </div>
                        <div class="product-actions">
                            <button class="product-btn danger" onclick="confirmDeleteProduct(${product.id}); closeModal('delete-product-modal')">
                                DELETE
                            </button>
                        </div>
                    </div>
                `;
            });
            html += '</div>';

            content.innerHTML = html;
            modal.classList.add('show');
        }

        // Add Product Form Handler
        document.getElementById('add-product-form').addEventListener('submit', async function (e) {
            e.preventDefault();

            if (!walletConnected) {
                showStatus('❌ Please connect wallet to add products', 'error');
                return;
            }

            const formData = {
                name: document.getElementById('product-name').value,
                price: document.getElementById('product-price').value,
                stock: parseInt(document.getElementById('product-stock').value),
                category: document.getElementById('product-category').value,
                image: document.getElementById('product-emoji').value || '🎁',
                description: document.getElementById('product-description').value,
                delivery: document.getElementById('product-delivery').value,
                badge: document.getElementById('product-badge').value
            };

            try {
                showStatus('🔄 Adding product to blockchain...', 'info');

                // FIXED: Convert price to Wei before sending to contract
                const priceInWei = ethers.parseEther(formData.price.toString());

                console.log('✅ PRICE FIX: Adding product with price:', formData.price, 'ZTC =', priceInWei.toString(), 'Wei');

                // Create metadata JSON
                const metadata = JSON.stringify({
                    description: formData.description,
                    image: formData.image,
                    delivery: formData.delivery,
                    badge: formData.badge
                });

                // Call smart contract with Wei price
                const tx = await contract.addProduct(
                    formData.name,
                    priceInWei, // ← FIXED: Send Wei amount instead of display amount
                    formData.stock,
                    formData.category,
                    metadata,
                    {
                        gasLimit: 500000,
                        gasPrice: ethers.parseUnits('100', 'gwei')
                    }
                );

                showStatus('⏳ Waiting for transaction confirmation...', 'info');
                const receipt = await tx.wait();

                closeModal('add-product-modal');
                this.reset();

                showStatus('✅ Product added successfully! Price: ' + formData.price + ' ZTC', 'success');

                // Refresh products and stats
                setTimeout(() => {
                    viewAllProducts();
                    updateAllStats();
                }, 2000);

            } catch (error) {
                console.error('Error adding product:', error);
                let errorMsg = error.message;
                if (error.message.includes('insufficient funds')) {
                    errorMsg = 'Insufficient funds for gas fees';
                } else if (error.message.includes('user rejected')) {
                    errorMsg = 'Transaction cancelled by user';
                }
                showStatus('❌ Error adding product: ' + errorMsg, 'error');
            }
        });

        // Statistics Updates
        async function updateAllStats() {
            try {
                // purchase-level stats
                const filter = contract.filters.ProductPurchased();
                const events = await contract.queryFilter(filter, 0, 'latest');

                let revenue = 0;
                let customers = new Set();
                events.forEach(ev => {
                    revenue += parseFloat(ethers.formatEther(ev.args.totalPrice));
                    customers.add(ev.args.buyer);
                });

                document.getElementById('total-purchases').textContent = events.length;
                document.getElementById('total-revenue').textContent = revenue.toFixed(2);
                document.getElementById('unique-customers').textContent = customers.size;

                // product-level stats (store cache)
                const products = getStoreProducts();
                updateProductStats(products);

            } catch (err) {
                console.log('Could not update all stats:', err.message);
                ['total-purchases', 'total-revenue', 'unique-customers'].forEach(id => {
                    document.getElementById(id).textContent = '-';
                });
            }
        }


        function updateProductStats(products) {
            const totalProducts = products.length;
            const lowStockCount = products.filter(p => p.stock <= 5 && p.stock > 0).length;

            document.getElementById('total-products').textContent = totalProducts;
            document.getElementById('low-stock-count').textContent = lowStockCount;
        }

        // Utility Functions
        function updateStatus(message, type, outputId = 'purchases-output') {
            const output = document.getElementById(outputId);
            if (!output) return;

            if (type) {
                output.innerHTML = `<div class="status-message ${type}">${message}</div>`;
            } else {
                output.innerHTML = message;
            }
        }

        function showStatus(message, type = 'info', duration = 4000) {
            console.log(`[${type.toUpperCase()}] ${message}`);

            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${type === 'success' ? 'var(--success-green)' :
                    type === 'error' ? 'var(--error-red)' :
                        type === 'warning' ? 'var(--warning-orange)' : 'var(--info-blue)'};
                color: white;
                padding: 1rem 1.5rem;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                z-index: 9999;
                max-width: 350px;
                font-weight: 500;
                transform: translateX(400px);
                transition: transform 0.3s ease-in-out;
            `;

            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => { toast.style.transform = 'translateX(0)'; }, 100);

            setTimeout(() => {
                toast.style.transform = 'translateX(400px)';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, duration);
        }

        // Modal Management
        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('show');
        }

        // Event Listeners
        document.addEventListener('click', function (e) {
            if (e.target.classList.contains('modal')) {
                e.target.classList.remove('show');
            }
        });

        // Initialize on load
        window.addEventListener('load', init);

        console.log('✅ ZenChain Admin Dashboard');
    </script>
</body>

</html>
